HW3 Due 11:59PM March 22

***Please review the top part of ../hw1/hw1.txt***
***Your chance of success greatly increases if you start very early. Your chance of failure increases if you start late. Please use as many reviews as you possibly can.***

1. According to the article <http://martinfowler.com/bliki/BeckDesignRules.html>, what are the rules of simple design. Why are these important? Discuss the impact of these principles. Give examples of using these principles in the class so far.

According to the article, the four rules of simple design are: (1) passes the tests, (2) reveals intention, (3) no duplication, and (4) fewest elements.

Test-driven development is integral for designs to work as intended because if the program does not fulfill its purpose, the rest of the design principles don't matter. For this reason, it is important that tests are written before the code to ensure that a program meets its specific requirements from the start. For example, when we started working on developing a version of Wordle, we first listed out the tests we believed we needed. Then, we implemented them one by one. This allowed us to focus on each feature and ensure that each one worked as intended before moving on to the next feature. Additionally, when testing for edge cases, we can refactor logic with confidence, allowing us to focus on a feature without inadvertently breaking the functionality of another feature.

Code that reveals intention is code that is easy to understand. It is important to communicate the purpose and functionality of the design to readers. This is vital when working with other developers, as it allows them to spend less time analyzing existing code and more time on development. It is crucial to clearly name variables, methods, and classes in a way that reflects their purpose and functionality. For example, while developing the Wordle GUI, we adopted a modular approach to avoid complexity in our code. Every chunk of code was defined by a method with a name that described its purpose. In our function called 'start_game,' we called 'draw_screen,' 'game_loop,' and 'end_game,' to provide greater detail in subsections of our code rather than writing overly complex nested loops. This approach allowed us to organize our code better and reveal its intention, clarifying the purpose of each part of the code. Another example of where we applied this rule was in naming our enums. Rather than using a generic name like "Positions", we named the enum for comparing letter positions as "TallyMatch". This allowed us to provide a more descriptive, intuitive name to better reflect the data being represented.

The DRY (Don't Repeat Yourself) principle emphasizes that good designs should have no duplication in code. Redundancy in code poses the risk for inconsistencies and bugs, increases maintenance as changes in one place might require adjustments where the code is duplicated, and can make it more difficult to identify bugs where logic is duplicated. Eliminating redundancy is more about creating a single source of truth within our program than about writing less code. Looking back at our Wordle application, we initially tested our tally function by creating a different unit test for each pair of words (the target and guess). However, it was pointed out that we were repeating ourselves, so we combined all the tally tests into one function called 'test_expected_tally' and added a group of test cases that the unit test would use. This approach ensures that following changes or enhancements would need to be made in only one place and reduces risk of errors.

Lastly, we have "fewest elements", which means that anything that doesn't serve the previous three rules should be removed. A simple design should be just that--simple. The YAGNI (You Aren't Gonna Need It) principle advocates to only add functionality when it's necessary in order to minimize complexity, cost of repair, and cost of carry and to keep the code base light and easy to modify. Having the fewest elements possible is important because it prevents our code from becoming too complex and inflexible. For example, when we first began developing our Wordle game, we had a class for WordleLogic. However, we ended up not needing a class, so we removed it. Another instance was applying SRP when adding the dependencies. Initially, we thought we had to implement an interface to make it easier to change the URL later on. But as it turned out, we just needed to move the dependencies to a separate file.

When adhering to the four rules of simple design, it is important to also note the order of priority. "Passes the test" is the most important rule. Following closely is "reveals intention" and "no duplication", both holding equal importance as they work in tandem to refine code. Last up is "fewest elements". When conflict arises during the application of these rules, it is necessary to prioritize passing the tests since it is the key indicator of whether or not the code is functional and up to standards. The same goes for the other three; if needed, it is best to compromise by adhering to the rule with the most priority over those with less significance. Doing so allows us to achieve balance, leading to a more maintainable, effective code design.

In summary, there are four main rules of simple design: passing tests, revealing intention, avoiding duplication, and minimizing elements. Test-driven development ensures functionality, while coding to reveal intention without duplication enhances readability and maintainability. By adhering to these principles, such as modularizing components and eliminating unnecessary elements, developers can maintain quality design that minimizes cost and maximizes benefits over the software's lifetime.

2. Give from examples outside of this class, but limit to your personal experiences. Mention your name and below that provide details of your experience related to the rules, but outside of this class.

---Chelsea Nguyen---
In my experience, before enrolling in this course, I didn't typically write tests to validate the functionality of my code. Instead, I would develop my code little by little, ensuring that each feature worked properly before progressing to the next. While this approach provided a deep understanding of the application's logic, it lacked the validation that tests offer. Despite its limitations, this iterative approach gave me experience that made it easier to adapt to structured testing practices in this course.

One instance where I applied the principles of "reveals intention" and "no duplication" was during a project involving different views for each user role. To avoid duplicating code for navigation elements across multiple pages, I went for a modular approach by implementing a NavBar component for each user role. Doing so allowed me to create an instance of the appropriate NavBar rather than coding out the entire NavBar on every single page. This approach helped maintain concise code and better reveal its intention. Furthermore, having the "fewest elements" would be when I refactored the HTML code to remove redundant elements. For example, I eliminated divs that served no purpose and refined the attributes within input tags.

---Carolyn Heron---

I have previously developed projects where I did not utilize test-first development, instead incrementally adding logic and features and "testing" the output against test cases by console logging the result and visually comparing it to an expected answer. This approach is very time-consuming and would often result in failing edge cases, requiring me to go back to identify bugs and make changes. While not an ideal experience, completing projects independently is still possible. However, when working in a group with other developers, it results in code that is hard to read and difficult to understand for others, thus prolonging the development process.

In a more recent web-dev project, I revealed intention by using a modular approach, separating elements into their most basic needs, and naming components and pages by what purpose they served, such as a sidebar, toast, or input. Additionally, this approach was used to avoid duplication by passing props to components that can be reused to serve multiple versions of the same process. This further allows me to minimize elements to keep the code more maintainable and to quickly make changes to one component used multiple times, rather than making redundant changes to multiple components with the same function.

Total [10]: 10
